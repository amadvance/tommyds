<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-2']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tommy Design </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Tommy is designed to fulfill the need for generic data structures for the C language, providing at the same time high performance and a clean and easy-to-use interface.</p>
<h1><a class="anchor" id="testing"></a>
Testing</h1>
<p >Extensive and automated tests with the runtime checker <a href="http://valgrind.org/">valgrind</a> and the static analyzer <a href="http://clang-analyzer.llvm.org/">clang</a> are done to ensure the correctness of the library.</p>
<p >The test has a <a href="https://www.tommyds.it/cov/tommyds/tommyds">code coverage of 100%</a>, measured with <a href="http://ltp.sourceforge.net/coverage/lcov.php">lcov</a>.</p>
<h1><a class="anchor" id="Limitations"></a>
Limitations</h1>
<p >Tommy is not thread-safe. You have always to provide thread safety using locks before calling any Tommy functions.</p>
<p >Tommy doesn't provide iterators for elements stored in a container. To iterate on elements you must insert them also into a <a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Doubly linked list type.">tommy_list</a>, and use the list as an iterator. See the <a class="el" href="multiindex.html">Multi-Indexing: Searching Objects in Multiple Ways</a> example for more details.</p>
<p >Tommy doesn't provide an error reporting mechanism for a malloc() failure. You have to provide it by redefining malloc() if you expect it to fail.</p>
<h1><a class="anchor" id="compromise"></a>
Compromises</h1>
<p >Finding the right balance between efficiency and ease of use required some compromises. Most of them are on memory efficiency, and were done to avoid crippling the interface.</p>
<p >The following is a list of such decisions.</p>
<h2><a class="anchor" id="multi_key"></a>
Multi key</h2>
<p >All the Tommy containers support the insertion of multiple elements with the same key, adding in each node a list of equal elements.</p>
<p >They are the equivalent of the C++ associative containers <a href="http://www.cplusplus.com/reference/map/multimap/">multimap&lt;unsigned,void*&gt;</a> and <a href="http://www.cplusplus.com/reference/unordered_map/unordered_multimap/">unordered_multimap&lt;unsigned,void*&gt;</a> that allow duplicates of the same key.</p>
<p >A more memory-conservative approach is to not allow duplicated elements, removing the need for this list.</p>
<h2><a class="anchor" id="data_pointer"></a>
Data pointer</h2>
<p >The <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">tommy_node::data</a> field is present to allow search and remove functions to return directly a pointer to the element stored in the container.</p>
<p >A more memory-conservative approach is to require the user to compute the element pointer from the embedded node with a fixed displacement. For an example, see the Linux Kernel declaration of <a href="http://lxr.free-electrons.com/ident?i=container_of">container_of()</a>.</p>
<h2><a class="anchor" id="insertion_order"></a>
Insertion order</h2>
<p >The list used for collisions is double-linked to allow insertion of elements at the end of the list to keep the insertion order of equal elements.</p>
<p >A more memory-conservative approach is to use a single-linked list, inserting elements only at the start of the list, losing the original insertion order.</p>
<h2><a class="anchor" id="zero_list"></a>
Zero terminated list</h2>
<p >The 0-terminated format of <a class="el" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">tommy_node::next</a> is present to provide a forward iterator terminating in 0. This allows the user to write a simple iteration loop over the list of elements in the same bucket.</p>
<p >A more efficient approach is to use a circular list, because operating on nodes in a circular list doesn't require managing the special terminating case when adding or removing elements. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
