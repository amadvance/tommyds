<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Tommy Design </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Tommy is designed to fulfill the need of generic data structures for the C language, providing at the same time high performance and a clean and easy to use interface.</p>
<h2><a class="anchor" id="testing"></a>
Testing</h2>
<p>Extensive and automated tests with the runtime checker <a href="http://valgrind.org/">valgrind</a> and the static analyzer <a href="http://clang-analyzer.llvm.org/">clang</a> are done to ensure the correctness of the library.</p>
<p>The test has a <a href="http://tommyds.sourceforge.net/cov/tommyds/tommyds">code coverage of 100%</a>, measured with <a href="http://ltp.sourceforge.net/coverage/lcov.php">lcov</a>.</p>
<h2><a class="anchor" id="Limitations"></a>
Limitations</h2>
<p>Tommy is not thread safe. You have always to provide thread safety using locks before calling any Tommy functions.</p>
<p>Tommy doesn't provide iterators over the implicit order defined by the data structures. To iterate on elements you must insert them also into a <a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list type.">tommy_list</a>, and use the list as iterator. See the <a class="el" href="multiindex.html">Tommy Multi Indexing</a> example for more details. Note that this is a real limitation only for <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie container type.">tommy_trie</a>, as it's the only data structure defining an useable order.</p>
<p>Tommy doesn't provide an error reporting mechanism for a malloc() failure. You have to provide it redefining malloc() if you expect it to fail.</p>
<p>Tommy assumes to never have more than 2^32-1 elements in a container.</p>
<h2><a class="anchor" id="compromise"></a>
Compromises</h2>
<p>Finding the right balance between efficency and easy to use, required some comprimises, mostly on memory efficency, to avoid to cripple the interface. The following is a list of such decisions.</p>
<h3><a class="anchor" id="multi_key"></a>
Multi key</h3>
<p>All the Tommy containers support the insertion of multiple elements with the same key, adding in each node a list of equal elements.</p>
<p>They are the equivalent at the C++ associative containers <a href="http://www.cplusplus.com/reference/map/multimap/">multimap&lt;unsigned,void*&gt;</a> and <a href="http://www.cplusplus.com/reference/unordered_map/unordered_multimap/">unordered_multimap&lt;unsigned,void*&gt;</a> that allow duplicates of the same key.</p>
<p>A more memory conservative approach is to not allow duplicated elements, removing the need of this list.</p>
<h3><a class="anchor" id="data_pointer"></a>
Data pointer</h3>
<p>The <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer at the object containing the node.">tommy_node::data</a> field is present to allow search and remove functions to return directly a pointer at the element stored in the container.</p>
<p>A more memory conservative approach is to require the user to compute the element pointer from the embedded node with a fixed displacement. For an example, see the Linux Kernel declaration of <a href="http://lxr.free-electrons.com/ident?i=container_of">container_of()</a>.</p>
<h3><a class="anchor" id="insertion_order"></a>
Insertion order</h3>
<p>The list used for collisions is double linked to allow insertion of elements at the end of the list to keep the insertion order of equal elements.</p>
<p>A more memory conservative approach is to use a single linked list, inserting elements only at the start of the list, losing the original insertion order.</p>
<h3><a class="anchor" id="zero_list"></a>
Zero terminated list</h3>
<p>The 0 terminated format of <a class="el" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">tommy_node::next</a> is present to provide a forward iterator terminating in 0. This allows the user to write a simple iteration loop over the list of elements in the same bucket.</p>
<p>A more efficient approach is to use a circular list, as operating on nodes in a circular list doesn't requires to manage the special terminating case when adding or removing elements. </p>
</div></div>
</body>
</html>
