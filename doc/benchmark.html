<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21967501-2']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tommy Benchmarks </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >To help you understand TommyDS's performance, we conducted a thorough benchmark, comparing it against some of the best and most popular existing C and C++ data structure libraries in the conditions of a <b>real-world</b> application.</p>
<p >Here are the data structures included in the comparison:</p><ul>
<li><a class="el" href="tommyhashtbl_8h.html#aa4d9626d450b1a0da8a5838a7177c4b1" title="Hashtable container type.">tommy_hashtable</a> - Fixed-size chained hashtable.</li>
<li><a class="el" href="tommyhashdyn_8h.html#ae3b3e52313d2da8e872e890e8185205b" title="Hashtable container type.">tommy_hashdyn</a> - Dynamic chained hashtable.</li>
<li><a class="el" href="tommyhashlin_8h.html#a1f83949c28fe369e100d2e44911c04c5" title="Hashtable container type.">tommy_hashlin</a> - Linear chained hashtable.</li>
<li><a class="el" href="tommytrie_8h.html#a3a77169f497c9ab7b03d80cf456a08e4" title="Trie container type.">tommy_trie</a> - Trie optimized for cache usage.</li>
<li><a class="el" href="tommytrieinp_8h.html#aa2db3b1aa9bfc7cfc87c19aa9777634e" title="Trie container type.">tommy_trie_inplace</a> - Trie completely inplace.</li>
<li><a href="http://www.canonware.com/rb/">rbtree</a> - Red-black tree by Jason Evans.</li>
<li><a href="http://www.nedprod.com/programs/portable/nedtries/">nedtrie</a> - Binary trie inplace by Niall Douglas.</li>
<li><a href="https://github.com/attractivechaos/klib/blob/master/khash.h">khash</a> - Dynamic open addressing hashtable by Attractive Chaos.</li>
<li><a href="http://uthash.sourceforge.net/">uthash</a> - Dynamic chaining hashtable by Troy D. Hanson.</li>
<li><a href="http://judy.sourceforge.net/">judy</a> - Burst trie (JudyL) by Doug Baskins.</li>
<li><a href="https://code.google.com/archive/p/judyarray/">judyarray</a> - Burst trie by Karl Malbrain.</li>
<li><a href="https://github.com/sparsehash/sparsehash">googledensehash</a> - Dynamic open addressing hashtable by Craig Silverstein at Google (2.0.4).</li>
<li><a href="http://code.google.com/p/cpp-btree/">googlebtree</a> - B-tree by Google.</li>
<li><a href="http://panthema.net/2007/stx-btree/">stxbtree</a> - STX B-tree by Timo Bingmann.</li>
<li><a href="http://www.cplusplus.com/reference/unordered_map/unordered_map/">c++unordered_map</a> - C++ STL unordered_map&lt;&gt; template.</li>
<li><a href="http://www.cplusplus.com/reference/map/map/">c++map</a> - C++ STL map&lt;&gt; template.</li>
<li><a href="https://sites.google.com/site/binarysearchcube/">tesseract</a> - Binary Search Tesseract by Gregorius van den Hoven.</li>
<li><a href="https://github.com/sparsehash/sparsehash/tree/master/experimental">googlelibchash</a> - LibCHash by Craig Silverstein at Google.</li>
<li><a href="https://github.com/fredrikwidlund/libdynamic">libdynamic</a> - Hash set by Fredrik Widlund.</li>
<li><a href="http://concurrencykit.org/">concurrencykit</a> - Non-blocking hash set by Samy Al Bahra.</li>
</ul>
<p >Note that <em>googlelibchash</em>, <em>googledensehash</em> and <em>concurrencykit</em> are generally <b>not shown in the primary performance graphs</b> because they exhibit numerous performance spikes across different data sizes. You can find specific details and relevant graphs about these in the <a class="el" href="benchmark.html#notes">Notes on Other Libraries</a> section.</p>
<h1><a class="anchor" id="thebenchmark"></a>
Understanding the Benchmark Methodology</h1>
<p >The primary purpose of this benchmark is to measure the performance of storing and searching a collection of N pointers to distinct objects, indexed by an associated integer key.</p>
<p >This test methodology deliberately <b>deviates from typical hash table comparisons</b> where the entire object's data is copied and stored directly within the container.</p>
<p >Storing pointers is a <b>more common requirement</b> in real-world applications where the same object must be referenced by or included in multiple data structures (see <a class="el" href="multiindex.html">Multi-Indexing: Searching Objects in Multiple Ways</a>). Duplicating the object in such cases would be inefficient or incorrect. This difference is critical and explains why these performance metrics may differ from other general-purpose hash table comparisons.</p>
<p >To accurately simulate real-world usage where the application must retrieve and access the object's data, the search operation in this benchmark dereferences the stored pointers. This step typically necessitates an additional memory load, often resulting in a cache miss.</p>
<p >This overhead provides a relative performance advantage to <b>intrusive containers</b> (like the Tommy structures) where the required indexing metadata is stored directly within the user's object structure. For these designs, the cache miss incurred to access the object's data is the same one that retrieves the necessary indexing information, minimizing the "additional" cost.</p>
<p >The tests performed are:</p><ul>
<li><b>Insert:</b> Measures the time taken to add all N objects, starting from an empty container.</li>
<li><b>Change:</b> Measures the time taken to <b>Find</b>, <b>Remove</b>, and immediately <b>Reinsert</b> an object with a <em>new</em> key, repeated for all N objects.</li>
<li><b>Hit:</b> Measures the time taken to successfully <b>Find</b> all N objects and then <b>Dereference</b> (access) them.</li>
<li><b>Miss:</b> Measures the time taken to attempt to find N objects that are <b>not present</b> in the container.</li>
<li><b>Remove:</b> Measures the time taken to <b>Find</b> and <b>Remove</b> all N objects.</li>
</ul>
<p >Note that <em>Change</em>, <em>Hit</em>, and <em>Miss</em> tests are always performed with N objects already in the container, while <em>Insert</em> builds the container up, and <em>Remove</em> empties it. The objects are always dereferenced upon successful search and removal.</p>
<p >All objects are preallocated on the heap, and the time for memory allocation/deallocation itself is not included in the performance results.</p>
<p >Each object contains a unique integer key, a value field for consistency checks, and a 16-byte unused <em>payload</em> field, plus any required internal data structure links.</p>
<p >The keys used are unique and form a dense domain starting at 0x80000000 and consisting of N even numbers (e.g., 0x80000000, 0x80000002, ...).</p><ul>
<li>Using even numbers ensures there are missing keys (the odd numbers) <em>within</em> the domain range, which is crucial for realistic <em>Miss</em> and <em>Change</em> tests.</li>
<li>Starting the key domain at 0x80000000 (instead of 0) prevents unfair advantages for data structures that might have special optimizations for keys near zero.</li>
<li>For hashtables, keys are processed using the <a class="el" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits.">tommy_inthash_u32()</a> function, which is designed to guarantee a uniform distribution and no hash collisions, providing an optimal scenario.</li>
<li>For tries and trees, the keys are used directly (not hashed).</li>
</ul>
<p >Tests are repeated using two key access modes:</p>
<ul>
<li><b>Random Mode:</b> Keys are accessed in a completely random order. This represents the real-world worst case and generally favors hashtables because the key-hashing process already randomizes the access pattern.</li>
<li><b>Forward Mode:</b> Keys are accessed in order from the lowest to the highest. This naturally advantages tries and trees as they exploit the consecutive nature of the keys for cache locality.</li>
</ul>
<h1><a class="anchor" id="result"></a>
Results Summary</h1>
<p >The most significant tests depend on your data usage model, but if in doubt, focus on <b>Random Hit</b> and <b>Random Change</b>, as they represent the real-world worst-case random access scenario.</p>
<h3><a class="anchor" id="autotoc_md0"></a>
Random Hit Analysis</h3>
<p ><img src="core_i7_10700_2G9_linux/img_random_hit.png" alt="" class="inline"/></p>
<p >Observe the vertical split around the 100,000 element limit.</p><ul>
<li><b>Below 100k:</b> The modern processor's cache can contain most of the data, resulting in extremely fast access for almost all structures.</li>
<li><b>Above 100k:</b> The number of <b>cache misses</b> becomes the dominant factor.</li>
<li><b>Hashtables</b> are nearly constant-time, showing almost no growth (O(1)).</li>
<li><b>Trees (rbtree, nedtrie)</b> grow logarithmically as log_2(N).</li>
<li><b>Tommy Tries</b> show better logarithmic growth: <a class="el" href="tommytrieinp_8h.html#aa2db3b1aa9bfc7cfc87c19aa9777634e" title="Trie container type.">tommy_trie_inplace</a> grows as log_4(N), and <a class="el" href="tommytrie_8h.html#a3a77169f497c9ab7b03d80cf456a08e4" title="Trie container type.">tommy_trie</a> as log_8(N). The growth curve for Tommy Tries can be adjusted by configuring the number of branches per node.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1"></a>
Random Change Analysis</h3>
<p ><img src="core_i7_10700_2G9_linux/img_random_change.png" alt="" class="inline"/></p>
<p >The <em>Random Change</em> graph confirms the 100,000 element cache limit split. It also highlights that <b>hashtables are almost unbeatable</b> for random-access combined remove and insert operations.</p>
<h1><a class="anchor" id="random"></a>
Full Random Order Results</h1>
<p >In the <b>Random</b> access tests, <b>hashtables are the clear winners</b>, followed by tries, with traditional trees generally being the slowest.</p>
<p >The best choices in TommyDS for this access pattern are <a class="el" href="tommyhashdyn_8h.html#ae3b3e52313d2da8e872e890e8185205b" title="Hashtable container type.">tommy_hashdyn</a> and <a class="el" href="tommyhashlin_8h.html#a1f83949c28fe369e100d2e44911c04c5" title="Hashtable container type.">tommy_hashlin</a>. <a class="el" href="tommyhashlin_8h.html#a1f83949c28fe369e100d2e44911c04c5" title="Hashtable container type.">tommy_hashlin</a> is often preferred for being <b>real-time friendly</b> as it minimizes heap fragmentation.</p>
<table border="0">
<tr>
<td><img src="core_i7_10700_2G9_linux/img_random_insert.png" alt="" class="inline"/> </td></tr>
<tr>
<td><img src="core_i7_10700_2G9_linux/img_random_hit.png" alt="" class="inline"/> </td></tr>
<tr>
<td><img src="core_i7_10700_2G9_linux/img_random_miss.png" alt="" class="inline"/> </td></tr>
<tr>
<td><img src="core_i7_10700_2G9_linux/img_random_change.png" alt="" class="inline"/> </td></tr>
<tr>
<td><img src="core_i7_10700_2G9_linux/img_random_remove.png" alt="" class="inline"/>  </td></tr>
</table>
<h1><a class="anchor" id="forward"></a>
Full Forward Order Access</h1>
<p >In the <b>Forward</b> (sequential) access tests, <b>tries are the fastest</b>, followed by hashtables. Trees remain the slowest option.</p>
<p >The best choices in TommyDS here are <a class="el" href="tommytrie_8h.html#a3a77169f497c9ab7b03d80cf456a08e4" title="Trie container type.">tommy_trie</a> and <a class="el" href="tommytrieinp_8h.html#aa2db3b1aa9bfc7cfc87c19aa9777634e" title="Trie container type.">tommy_trie_inplace</a>. <a class="el" href="tommytrieinp_8h.html#aa2db3b1aa9bfc7cfc87c19aa9777634e" title="Trie container type.">tommy_trie_inplace</a> is often preferred as it <b>does not require a custom allocator</b>.</p>
<p >Note that hashtables are also faster in Forward mode than in Random mode. This happens because the objects are <b>allocated sequentially in memory</b>, and accessing them in key order still results in better cache utilization overall.</p>
<table border="0">
<tr>
<td><img src="core_i7_10700_2G9_linux/img_forward_insert.png" alt="" class="inline"/> </td></tr>
<tr>
<td><img src="core_i7_10700_2G9_linux/img_forward_hit.png" alt="" class="inline"/> </td></tr>
<tr>
<td><img src="core_i7_10700_2G9_linux/img_forward_miss.png" alt="" class="inline"/> </td></tr>
<tr>
<td><img src="core_i7_10700_2G9_linux/img_forward_change.png" alt="" class="inline"/> </td></tr>
<tr>
<td><img src="core_i7_10700_2G9_linux/img_forward_remove.png" alt="" class="inline"/>  </td></tr>
</table>
<h1><a class="anchor" id="size"></a>
Memory Usage</h1>
<p >Here you can see how memory usage scales for the different data structures.</p>
<table border="0">
<tr>
<td><img src="core_i7_10700_2G9_linux/img_random_size.png" alt="" class="inline"/> </td></tr>
</table>
<h1><a class="anchor" id="code"></a>
Technical Details and Code Snippets</h1>
<p >The benchmark was performed on a Core i7 10700 2.9 GHz running Linux. The compiler used was gcc 15.2.0 with the aggressive optimization flags <code>"-O3 -march=native -flto -fpermissive"</code>.</p>
<p >Below is the pseudo-code for the benchmark setup, written here using the C++ <code>unordered_map</code> as an example implementation:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define N 10000000 </span><span class="comment">// Number of elements</span></div>
<div class="line"><span class="preprocessor">#define PAYLOAD 16 </span><span class="comment">// Size of the object&#39;s payload data</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Basic object inserted in the collection</span></div>
<div class="line"><span class="keyword">struct </span>obj {</div>
<div class="line">    <span class="keywordtype">unsigned</span> value; <span class="comment">// Key used for searching</span></div>
<div class="line">    <span class="keywordtype">char</span> payload[PAYLOAD];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom hash function to avoid using the STL one</span></div>
<div class="line"><span class="keyword">class </span>custom_hash {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">unsigned</span> operator()(<span class="keywordtype">unsigned</span> key)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code hl_function" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71">tommy_inthash_u32</a>(key); }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Map collection from &quot;unsigned&quot; to &quot;pointer to object&quot;</span></div>
<div class="line"><span class="keyword">typedef</span> std::unordered_map&lt;unsigned, obj*, custom_hash&gt; bag_t;</div>
<div class="line">bag_t bag;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Preallocate objects</span></div>
<div class="line">obj* OBJ = <span class="keyword">new</span> obj[N];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Keys used for inserting and searching elements</span></div>
<div class="line"><span class="keywordtype">unsigned</span> INSERT[N];</div>
<div class="line"><span class="keywordtype">unsigned</span> SEARCH[N];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize the keys</span></div>
<div class="line"><span class="keywordflow">for</span>(i=0;i&lt;N;++i) {</div>
<div class="line">    INSERT[i] = 0x80000000 + i * 2;</div>
<div class="line">    SEARCH[i] = 0x80000000 + i * 2;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If random order is required, shuffle the keys with Fisher-Yates</span></div>
<div class="line"><span class="comment">// The two key orders are not correlated</span></div>
<div class="line"><span class="keywordflow">if</span> (test_random) {</div>
<div class="line">    std::random_shuffle(INSERT, INSERT + N);</div>
<div class="line">    std::random_shuffle(SEARCH, SEARCH + N);</div>
<div class="line">}</div>
<div class="ttc" id="atommyhash_8h_html_aea9c8438064a941d13e6f5462b5bff71"><div class="ttname"><a href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71">tommy_inthash_u32</a></div><div class="ttdeci">tommy_uint32_t tommy_inthash_u32(tommy_uint32_t key)</div><div class="ttdoc">Integer reversible hash function for 32 bits.</div><div class="ttdef"><b>Definition:</b> tommyhash.h:103</div></div>
</div><!-- fragment --><h2><a class="anchor" id="insertion"></a>
Insert benchmark</h2>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(i=0;i&lt;N;++i) {</div>
<div class="line">    <span class="comment">// Setup the element to insert</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> key = INSERT[i];</div>
<div class="line">    obj* element = &amp;OBJ[i];</div>
<div class="line">    element-&gt;value = key;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Insert it</span></div>
<div class="line">    bag[key] = element;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="change"></a>
Change benchmark</h2>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(i=0;i&lt;N;++i) {</div>
<div class="line">    <span class="comment">// Search for the element</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> key = SEARCH[i];</div>
<div class="line">    bag_t::iterator j = bag.find(key);</div>
<div class="line">    <span class="keywordflow">if</span> (j == bag.end())</div>
<div class="line">        abort();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Remove it</span></div>
<div class="line">    obj* element = j-&gt;second;</div>
<div class="line">    bag.erase(j);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Reinsert the element with a new key</span></div>
<div class="line">    <span class="comment">// Use +1 in the key to ensure that the new key is unique</span></div>
<div class="line">    key = INSERT[i] + 1;</div>
<div class="line">    element-&gt;value = key;</div>
<div class="line">    bag[key] = element;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="hit"></a>
Hit benchmark</h2>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(i=0;i&lt;N;++i) {</div>
<div class="line">    <span class="comment">// Search for the element</span></div>
<div class="line">    <span class="comment">// Use a different key order than insertion</span></div>
<div class="line">    <span class="comment">// Use +1 in the key because we run after the &quot;Change&quot; test</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> key = SEARCH[i] + 1;</div>
<div class="line">    bag_t::const_iterator j = bag.find(key);</div>
<div class="line">    <span class="keywordflow">if</span> (j == bag.end())</div>
<div class="line">        abort();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Ensure that it&#39;s the correct element.</span></div>
<div class="line">    <span class="comment">// This operation is like using the object after finding it,</span></div>
<div class="line">    <span class="comment">// and likely involves a cache-miss operation.</span></div>
<div class="line">    obj* element = j-&gt;second;</div>
<div class="line">    <span class="keywordflow">if</span> (element-&gt;value != key)</div>
<div class="line">        abort();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="miss"></a>
Miss benchmark</h2>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(i=0;i&lt;N;++i) {</div>
<div class="line">    <span class="comment">// Search for the element</span></div>
<div class="line">    <span class="comment">// All the keys are now shifted by +1 by the &quot;Change&quot; test, and we&#39;ll find nothing</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> key = SEARCH[i];</div>
<div class="line">    bag_t::const_iterator j = bag.find(key);</div>
<div class="line">    <span class="keywordflow">if</span> (j != bag.end())</div>
<div class="line">        abort();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="remove"></a>
Remove benchmark</h2>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(i=0;i&lt;N;++i) {</div>
<div class="line">    <span class="comment">// Search for the element</span></div>
<div class="line">    <span class="comment">// Use +1 in the key because we run after the &quot;Change&quot; test</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> key = SEARCH[i] + 1;</div>
<div class="line">    bag_t::iterator j = bag.find(key);</div>
<div class="line">    <span class="keywordflow">if</span> (j == bag.end())</div>
<div class="line">        abort();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Remove it</span></div>
<div class="line">    bag.erase(j);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Ensure that it&#39;s the correct element.</span></div>
<div class="line">    obj* element = j-&gt;second;</div>
<div class="line">    <span class="keywordflow">if</span> (element-&gt;value != key)</div>
<div class="line">        abort();</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="notes"></a>
Notes on Other Libraries</h1>
<p >This section provides additional context on the tested libraries that are not part of TommyDS.</p>
<h2><a class="anchor" id="googlelibchash"></a>
Google C libchash</h2>
<p >This C implementation was excluded from the main graphs because it exhibits poor performance and significant spikes in the <em>Change</em> test for certain N values. See this <a href="other/googlelibchash_problem.png">performance graph</a> for a visual illustration of the issue.</p>
<h2><a class="anchor" id="googledensehash"></a>
Google C++ densehash</h2>
<p >This C++ implementation exhibits erratic performance with significant spikes during the <em>Change</em> benchmark test, particularly in version 2.0.4. The older version 2.0.3 does not exhibit this behavior.</p>
<p >The performance degradation is likely caused by the revised reallocation strategy in 2.0.4, which enters a pathological case under the specific access patterns of this test.</p>
<p >This type of degeneration is characteristic of hash tables that use tombstone entries for deletion handling, where the accumulation of tombstones can lead to increased probe lengths and degraded performance.</p>
<p >Note that downgrading to version 2.0.3 avoids this specific issue but does not guarantee immunity from similar pathological cases under different workloads or access patterns.</p>
<p >See this <a href="other/googledensehash_problem.png">performance graph</a> for a visual illustration of the issue.</p>
<p >Additionally, it does not automatically release memory upon deletion. To prevent an unfair advantage in the <em>Remove</em> test, we forced a periodic memory release by calling <code>resize(0)</code>.</p>
<h2><a class="anchor" id="khash"></a>
khash</h2>
<p >This library does not release memory when elements are deleted, which can lead to an unfair performance advantage in the <em>Remove</em> test. It also does not provide a way to shrink its internal storage, so this advantage remains in the benchmark.</p>
<h2><a class="anchor" id="nedtrie"></a>
nedtrie</h2>
<p >A crash bug was found when inserting a key with the value 0. The issue was reported to the author and the necessary <a href="https://github.com/ned14/nedtries/commit/21039696f27db4ffac70a82f89dc5d00ae74b332">fix</a> has been implemented.</p>
<h2><a class="anchor" id="judy"></a>
Judy</h2>
<p >The Judy library (specifically JudyL) can sometimes exhibit unpredictable performance depending on the specific platform and input data size. See for instance this <a href="other/judy_problem.png">graph</a> showing a big, reproducible performance spike at 50,000 elements.</p>
<h2><a class="anchor" id="ck"></a>
Concurrency Kit</h2>
<p >The non-blocking hash set displays severe performance degradation and numerous spikes in the <em>Change</em> test for some data sizes.</p>
<p >This type of degeneration is characteristic of hash tables that use tombstone entries for deletion handling, where the accumulation of tombstones can lead to increased probe lengths and degraded performance.</p>
<p >See this <a href="other/ck_problem.png">performance graph</a> for a visual illustration of the issue. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
